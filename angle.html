<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>맞춤 앵글 제작 시뮬레이터</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-body: #f3f4f6;
            --bg-panel: #ffffff;
            --text-main: #111827;
            --text-sub: #6b7280;
            --border: #e5e7eb;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: var(--bg-body);
            color: var(--text-main);
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        /* --- [수정] 사이드바 너비 축소 (360px -> 220px) --- */
        .sidebar {
            width: 220px; 
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            flex-shrink: 0; /* 화면이 줄어도 사이드바 크기 고정 */
        }

        .header {
            padding: 20px 15px;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 18px; /* 폰트 사이즈 조정 */
            font-weight: 700;
            color: var(--text-main);
            line-height: 1.2;
        }

        .controls {
            flex: 1;
            padding: 15px; /* 패딩 축소 */
            overflow-y: auto;
        }

        .input-group { margin-bottom: 15px; }
        
        .input-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-sub);
            margin-bottom: 5px;
        }

        .input-row {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 14px;
            text-align: right;
            outline: none;
            transition: 0.2s;
            font-weight: 500;
        }
        input[type="number"]:focus { 
            border-color: var(--primary); 
            background: #eff6ff;
        }
        .unit { font-size: 12px; color: var(--text-sub); width: 25px;}

        #btn-run {
            width: 100%;
            padding: 12px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.2s, transform 0.1s;
        }

        #btn-run:hover { background: var(--primary-hover); }
        #btn-run:active { transform: translateY(1px); }

        /* --- [수정] 견적 영역 제거 및 버튼 스타일 정리 --- */
        .footer-actions {
            padding: 15px;
            background: #f8fafc;
            border-top: 1px solid var(--border);
        }

        .btn-download {
            width:100%; 
            padding: 10px; 
            border:1px solid #d1d5db; 
            background:white; 
            border-radius:6px; 
            cursor:pointer;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-sub);
            transition: all 0.2s;
        }
        .btn-download:hover { background: #f3f4f6; color: var(--text-main); border-color: #9ca3af;}

        .viewer {
            flex: 1;
            position: relative;
            background: #eef2f6;
        }

        #canvas-container { width: 100%; height: 100%; }

        .guide-text {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            color: #555;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            font-weight: 500;
        }
    </style>
</head>
<body>

    <div class="sidebar">
        <div class="header">
            <h1>앵글 시뮬레이터</h1>
        </div>

        <div class="controls">
            <div class="input-group">
                <label>가로 (Width)</label>
                <div class="input-row">
                    <input type="number" id="input-w" value="1200" step="100" min="300">
                    <span class="unit">mm</span>
                </div>
            </div>

            <div class="input-group">
                <label>깊이 (Depth)</label>
                <div class="input-row">
                    <input type="number" id="input-d" value="600" step="100" min="300">
                    <span class="unit">mm</span>
                </div>
            </div>

            <div class="input-group">
                <label>높이 (Height)</label>
                <div class="input-row">
                    <input type="number" id="input-h" value="1800" step="100" min="600">
                    <span class="unit">mm</span>
                </div>
            </div>

            <div class="input-group">
                <label>선반 단수</label>
                <div class="input-row">
                    <input type="number" id="input-s" value="5" step="1" min="2" max="10">
                    <span class="unit">단</span>
                </div>
            </div>

            <button id="btn-run" onclick="updateFurniture()">실행하기</button>
        </div>

        <div class="footer-actions">
            <button class="btn-download" onclick="downloadImage()">이미지 저장</button>
        </div>
    </div>

    <div class="viewer">
        <div id="canvas-container"></div>
        <div class="guide-text">
            좌클릭: 회전 | 우클릭: 이동 | 휠: 줌
        </div>
    </div>

<script>
    let scene, camera, renderer, controls;
    let furnitureGroup;
    let dimGroup;

    // --- [수정] 입력 필드 클릭 시 값 자동 지우기 로직 ---
    document.addEventListener("DOMContentLoaded", () => {
        const inputs = document.querySelectorAll('input[type="number"]');
        inputs.forEach(input => {
            // 포커스(클릭) 되면 값을 비워서 입력하기 쉽게 함
            input.addEventListener('focus', function() {
                this.dataset.prevValue = this.value; // 만약을 위해 이전 값 저장
                this.value = '';
            });
            // 입력 안하고 나갔을 때(blur) 비어있으면 이전 값 복구 (오류 방지)
            input.addEventListener('blur', function() {
                if(this.value === '') {
                    this.value = this.dataset.prevValue || 0;
                }
            });
            // 엔터키 누르면 실행
            input.addEventListener('keydown', function(e) {
                if(e.key === 'Enter') updateFurniture();
            });
        });
        
        init();
    });

    function init() {
        const container = document.getElementById('canvas-container');

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeef2f6);

        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 10, 50000);
        camera.position.set(2800, 2200, 3500);

        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 500;
        controls.maxDistance = 10000;
        controls.maxPolarAngle = Math.PI / 2;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(2000, 3000, 2000);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        const d = 3000;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        const grid = new THREE.GridHelper(6000, 60, 0xcbd5e1, 0xe2e8f0);
        grid.material.opacity = 0.5;
        grid.material.transparent = true;
        scene.add(grid);

        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(10000, 10000),
            new THREE.MeshStandardMaterial({ color: 0xf8fafc, roughness: 0.8, metalness: 0.1 })
        );
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -2;
        plane.receiveShadow = true;
        scene.add(plane);

        window.addEventListener('resize', onWindowResize);

        updateFurniture();
        animate();
    }

    function updateFurniture() {
        if (furnitureGroup) cleanupGroup(furnitureGroup);
        if (dimGroup) cleanupGroup(dimGroup);

        const width = Number(document.getElementById('input-w').value) || 1200;
        const depth = Number(document.getElementById('input-d').value) || 600;
        const height = Number(document.getElementById('input-h').value) || 1800;
        const shelves = Number(document.getElementById('input-s').value) || 5;

        furnitureGroup = new THREE.Group();
        dimGroup = new THREE.Group();

        // === 모델링 ===
        const angleSize = 40;
        const angleThick = 3;
        
        const matSteel = new THREE.MeshStandardMaterial({ 
            color: 0x334155, 
            roughness: 0.5, 
            metalness: 0.7 
        });
        const matWood = new THREE.MeshStandardMaterial({ 
            color: 0xeebb99,
            roughness: 0.9,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        // 기둥
        const createPost = (x, z, rotY) => {
            const post = new THREE.Group();
            const mesh1 = new THREE.Mesh(new THREE.BoxGeometry(angleSize, height, angleThick), matSteel);
            mesh1.position.set(0, height/2, -angleSize/2 + angleThick/2);
            mesh1.castShadow = true;
            const mesh2 = new THREE.Mesh(new THREE.BoxGeometry(angleThick, height, angleSize), matSteel);
            mesh2.position.set(-angleSize/2 + angleThick/2, height/2, 0);
            mesh2.castShadow = true;
            post.add(mesh1, mesh2);
            post.position.set(x, 0, z);
            post.rotation.y = rotY;
            return post;
        };

        const halfW = width / 2;
        const halfD = depth / 2;
        const offset = angleSize / 2;

        furnitureGroup.add(createPost(-halfW + offset, -halfD + offset, 0));
        furnitureGroup.add(createPost(halfW - offset, -halfD + offset, -Math.PI/2));
        furnitureGroup.add(createPost(-halfW + offset, halfD - offset, Math.PI/2));
        furnitureGroup.add(createPost(halfW - offset, halfD - offset, Math.PI));

        // 선반
        const shelfSpacing = (height - 100) / (shelves - 1);
        const frameGeoW = new THREE.BoxGeometry(width, angleSize, angleThick);
        const frameGeoD = new THREE.BoxGeometry(angleThick, angleSize, depth);
        const boardGeo = new THREE.BoxGeometry(width - 5, 12, depth - 5);

        for (let i = 0; i < shelves; i++) {
            const y = 50 + (i * shelfSpacing);
            const board = new THREE.Mesh(boardGeo, matWood);
            board.position.set(0, y + 6, 0);
            board.castShadow = true;
            board.receiveShadow = true;
            furnitureGroup.add(board);

            const fw1 = new THREE.Mesh(frameGeoW, matSteel); fw1.position.set(0, y, halfD - angleThick/2);
            const fw2 = new THREE.Mesh(frameGeoW, matSteel); fw2.position.set(0, y, -halfD + angleThick/2);
            const fd1 = new THREE.Mesh(frameGeoD, matSteel); fd1.position.set(halfW - angleThick/2, y, 0);
            const fd2 = new THREE.Mesh(frameGeoD, matSteel); fd2.position.set(-halfW + angleThick/2, y, 0);
            furnitureGroup.add(fw1, fw2, fd1, fd2);
        }

        createModernDimensions(width, depth, height);

        scene.add(furnitureGroup);
        scene.add(dimGroup);
    }

    function createModernDimensions(w, d, h) {
        const dimColor = 0x2563eb;
        const dimWidth = 4;
        const offset = 200;

        const drawThickLine = (p1, p2) => {
            const vec = new THREE.Vector3().subVectors(p2, p1);
            const height = vec.length();
            const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            const geo = new THREE.CylinderGeometry(dimWidth, dimWidth, height, 8);
            const mat = new THREE.MeshBasicMaterial({ color: dimColor });
            const line = new THREE.Mesh(geo, mat);
            line.position.copy(mid);
            line.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), vec.clone().normalize());
            return line;
        };

        const drawMarker = (pos) => {
            const geo = new THREE.SphereGeometry(dimWidth * 3, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: dimColor });
            const marker = new THREE.Mesh(geo, mat);
            marker.position.copy(pos);
            return marker;
        }

        const createHighResLabel = (text) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 256;
            
            ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
            ctx.strokeStyle = "#2563eb";
            ctx.lineWidth = 10;
            roundRect(ctx, 20, 50, 472, 156, 40, true, true);

            ctx.font = "bold 100px 'Noto Sans KR', sans-serif";
            ctx.fillStyle = "#1e3a8a";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 256, 128);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
            sprite.scale.set(400, 200, 1);
            return sprite;
        };

        const buildDimSet = (start, end, labelText, labelOffsetVec) => {
            const group = new THREE.Group();
            group.add(drawThickLine(start, end));
            group.add(drawMarker(start));
            group.add(drawMarker(end));
            
            const label = createHighResLabel(labelText);
            const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            label.position.copy(mid).add(labelOffsetVec);
            group.add(label);
            return group;
        }

        dimGroup.add(buildDimSet(
            new THREE.Vector3(-w/2, 0, d/2 + offset),
            new THREE.Vector3(w/2, 0, d/2 + offset),
            `W: ${w}`,
            new THREE.Vector3(0, 0, 100)
        ));

        dimGroup.add(buildDimSet(
            new THREE.Vector3(-w/2 - offset, 0, d/2),
            new THREE.Vector3(-w/2 - offset, h, d/2),
            `H: ${h}`,
            new THREE.Vector3(-150, 0, 0)
        ));

        dimGroup.add(buildDimSet(
            new THREE.Vector3(w/2 + offset, 0, -d/2),
            new THREE.Vector3(w/2 + offset, 0, d/2),
            `D: ${d}`,
            new THREE.Vector3(150, 0, 0)
        ));
    }

    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
    }

    function cleanupGroup(group) {
        scene.remove(group);
        group.traverse((child) => {
            if (child.isMesh || child.isSprite || child.isLine) {
                if(child.material.map) child.material.map.dispose();
                child.geometry.dispose();
                child.material.dispose();
            }
        });
    }

    function downloadImage() {
        renderer.render(scene, camera);
        const link = document.createElement('a');
        link.download = 'angle_simulation.png';
        link.href = renderer.domElement.toDataURL("image/png");
        link.click();
    }

    function onWindowResize() {
        const container = document.getElementById('canvas-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
