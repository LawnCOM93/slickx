<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÎßûÏ∂§ ÏïµÍ∏Ä Ï†úÏûë ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --primary: #2563eb;       /* Ïã†Î¢∞Í∞ê Ï£ºÎäî Î∏îÎ£® */
            --primary-hover: #1d4ed8;
            --bg-body: #f3f4f6;       /* Î∞ùÏùÄ ÌöåÏÉâ Î∞∞Í≤Ω */
            --bg-panel: #ffffff;      /* Ìù∞ÏÉâ Ìå®ÎÑê */
            --text-main: #111827;
            --text-sub: #6b7280;
            --border: #e5e7eb;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: var(--bg-body);
            color: var(--text-main);
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        /* ÏôºÏ™Ω ÏÇ¨Ïù¥ÎìúÎ∞î */
        .sidebar {
            width: 360px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
        }

        .header {
            padding: 24px;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 22px;
            font-weight: 700;
            color: var(--text-main);
        }

        .controls {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
        }

        .input-group { margin-bottom: 20px; }
        .input-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-sub);
            margin-bottom: 8px;
        }

        .input-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 16px;
            text-align: right;
            outline: none;
            transition: 0.2s;
            font-weight: 500;
        }
        input[type="number"]:focus { border-color: var(--primary); }
        .unit { font-size: 14px; color: var(--text-sub); width: 30px;}

        /* Ïã§Ìñâ Î≤ÑÌäº Ïä§ÌÉÄÏùº */
        #btn-run {
            width: 100%;
            padding: 16px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(37, 99, 235, 0.2);
        }

        #btn-run:hover { background: var(--primary-hover); }
        #btn-run:active { transform: translateY(2px); }

        .summary {
            padding: 24px;
            background: #f8fafc;
            border-top: 1px solid var(--border);
        }
        
        .price-display {
            font-size: 24px;
            font-weight: 800;
            color: var(--text-main);
            text-align: right;
            margin-bottom: 15px;
        }
        .price-label { font-size: 14px; color: var(--text-sub); float: left; font-weight: 500; margin-top: 8px;}

        .btn-download {
            width:100%; 
            padding:12px; 
            border:1px solid #d1d5db; 
            background:white; 
            border-radius:6px; 
            cursor:pointer;
            font-weight: 600;
            color: var(--text-sub);
            transition: all 0.2s;
        }
        .btn-download:hover { background: #f3f4f6; color: var(--text-main); }

        /* 3D Î∑∞Ïñ¥ ÏòÅÏó≠ */
        .viewer {
            flex: 1;
            position: relative;
            background: #eef2f6; /* Îçî Î∞ùÏùÄ Î∞∞Í≤Ω */
        }

        #canvas-container { width: 100%; height: 100%; }

        .guide-text {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            color: #555;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            font-weight: 500;
        }
    </style>
</head>
<body>

    <div class="sidebar">
        <div class="header">
            <h1>ÏïµÍ∏Ä Í∞ÄÍµ¨ ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</h1>
        </div>

        <div class="controls">
            <div class="input-group">
                <label>Í∞ÄÎ°ú (Width)</label>
                <div class="input-row">
                    <input type="number" id="input-w" value="1200" step="100" min="300">
                    <span class="unit">mm</span>
                </div>
            </div>

            <div class="input-group">
                <label>ÍπäÏù¥ (Depth)</label>
                <div class="input-row">
                    <input type="number" id="input-d" value="600" step="100" min="300">
                    <span class="unit">mm</span>
                </div>
            </div>

            <div class="input-group">
                <label>ÎÜíÏù¥ (Height)</label>
                <div class="input-row">
                    <input type="number" id="input-h" value="1800" step="100" min="600">
                    <span class="unit">mm</span>
                </div>
            </div>

            <div class="input-group">
                <label>ÏÑ†Î∞ò Îã®Ïàò (Shelves)</label>
                <div class="input-row">
                    <input type="number" id="input-s" value="5" step="1" min="2" max="10">
                    <span class="unit">Îã®</span>
                </div>
            </div>

            <button id="btn-run" onclick="updateFurniture()">Ïã§ÌñâÌïòÍ∏∞</button>
        </div>

        <div class="summary">
            <div class="price-display">
                <span class="price-label">ÏòàÏÉÅ Í≤¨Ï†Å (VATÌè¨Ìï®)</span>
                <span id="price-value">0</span> Ïõê
            </div>
            <button class="btn-download" onclick="downloadImage()">Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû•</button>
        </div>
    </div>

    <div class="viewer">
        <div id="canvas-container"></div>
        <div class="guide-text">
            üñ±Ô∏è Ï¢åÌÅ¥Î¶≠: ÌöåÏ†Ñ | Ïö∞ÌÅ¥Î¶≠: Ïù¥Îèô | Ìú†: ÌôïÎåÄ/Ï∂ïÏÜå
        </div>
    </div>

<script>
    let scene, camera, renderer, controls;
    let furnitureGroup;
    let dimGroup;

    function init() {
        const container = document.getElementById('canvas-container');

        // Scene & Camera
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeef2f6); // ÏïÑÏ£º Î∞ùÏùÄ ÌöåÏÉâ

        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 10, 50000);
        camera.position.set(2800, 2200, 3500); // Ïπ¥Î©îÎùº ÏúÑÏπò ÏïΩÍ∞Ñ Ï°∞Ï†ï

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding; // ÏÉâÏÉÅ Î≥¥Ï†ï
        container.appendChild(renderer.domElement);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 500;
        controls.maxDistance = 10000;
        controls.maxPolarAngle = Math.PI / 2; // Î∞îÎã• ÏïÑÎûòÎ°ú Ïïà ÎÇ¥Î†§Í∞ÄÍ≤å

        // Lights (Ï°∞Î™Ö Í∞ïÌôî)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(2000, 3000, 2000);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 5000;
        const d = 3000;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // Floor
        const grid = new THREE.GridHelper(6000, 60, 0xcbd5e1, 0xe2e8f0);
        grid.material.opacity = 0.5;
        grid.material.transparent = true;
        scene.add(grid);

        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(10000, 10000),
            new THREE.MeshStandardMaterial({ color: 0xf8fafc, roughness: 0.8, metalness: 0.1 })
        );
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -2;
        plane.receiveShadow = true;
        scene.add(plane);

        window.addEventListener('resize', onWindowResize);

        updateFurniture();
        animate();
    }

    function updateFurniture() {
        // Í∏∞Ï°¥ Í∞ùÏ≤¥ Ï†ïÎ¶¨
        if (furnitureGroup) cleanupGroup(furnitureGroup);
        if (dimGroup) cleanupGroup(dimGroup);

        const width = Number(document.getElementById('input-w').value) || 1200;
        const depth = Number(document.getElementById('input-d').value) || 600;
        const height = Number(document.getElementById('input-h').value) || 1800;
        const shelves = Number(document.getElementById('input-s').value) || 5;

        furnitureGroup = new THREE.Group();
        dimGroup = new THREE.Group();

        // === Î™®Îç∏ÎßÅ ===
        const angleSize = 40;
        const angleThick = 3;
        
        // Ïû¨Ïßà Í∞úÏÑ†
        const matSteel = new THREE.MeshStandardMaterial({ 
            color: 0x334155, // Slate 700
            roughness: 0.5, 
            metalness: 0.7 
        });
        const matWood = new THREE.MeshStandardMaterial({ 
            color: 0xeebb99, // Îî∞ÎúªÌïú ÎÇòÎ¨¥ÏÉâ
            roughness: 0.9,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        // 1. Í∏∞Îë• ÏÉùÏÑ±
        const createPost = (x, z, rotY) => {
            const post = new THREE.Group();
            const mesh1 = new THREE.Mesh(new THREE.BoxGeometry(angleSize, height, angleThick), matSteel);
            mesh1.position.set(0, height/2, -angleSize/2 + angleThick/2);
            mesh1.castShadow = true;
            const mesh2 = new THREE.Mesh(new THREE.BoxGeometry(angleThick, height, angleSize), matSteel);
            mesh2.position.set(-angleSize/2 + angleThick/2, height/2, 0);
            mesh2.castShadow = true;
            post.add(mesh1, mesh2);
            post.position.set(x, 0, z);
            post.rotation.y = rotY;
            return post;
        };

        const halfW = width / 2;
        const halfD = depth / 2;
        const offset = angleSize / 2;

        furnitureGroup.add(createPost(-halfW + offset, -halfD + offset, 0));
        furnitureGroup.add(createPost(halfW - offset, -halfD + offset, -Math.PI/2));
        furnitureGroup.add(createPost(-halfW + offset, halfD - offset, Math.PI/2));
        furnitureGroup.add(createPost(halfW - offset, halfD - offset, Math.PI));

        // 2. ÏÑ†Î∞ò Î∞è ÌîÑÎ†àÏûÑ ÏÉùÏÑ±
        const shelfSpacing = (height - 100) / (shelves - 1);
        const frameGeoW = new THREE.BoxGeometry(width, angleSize, angleThick);
        const frameGeoD = new THREE.BoxGeometry(angleThick, angleSize, depth);
        const boardGeo = new THREE.BoxGeometry(width - 5, 12, depth - 5);

        for (let i = 0; i < shelves; i++) {
            const y = 50 + (i * shelfSpacing);

            // Ìï©Ìåê
            const board = new THREE.Mesh(boardGeo, matWood);
            board.position.set(0, y + 6, 0);
            board.castShadow = true;
            board.receiveShadow = true;
            furnitureGroup.add(board);

            // ÌîÑÎ†àÏûÑ
            const fw1 = new THREE.Mesh(frameGeoW, matSteel); fw1.position.set(0, y, halfD - angleThick/2);
            const fw2 = new THREE.Mesh(frameGeoW, matSteel); fw2.position.set(0, y, -halfD + angleThick/2);
            const fd1 = new THREE.Mesh(frameGeoD, matSteel); fd1.position.set(halfW - angleThick/2, y, 0);
            const fd2 = new THREE.Mesh(frameGeoD, matSteel); fd2.position.set(-halfW + angleThick/2, y, 0);
            furnitureGroup.add(fw1, fw2, fd1, fd2);
        }

        // === ÏπòÏàòÏÑ† ÏÉùÏÑ± (ÎîîÏûêÏù∏ Í∞úÏÑ†Îê®) ===
        createModernDimensions(width, depth, height);

        scene.add(furnitureGroup);
        scene.add(dimGroup);

        calculateCost(width, depth, height, shelves);
    }

    // --- Í∞úÏÑ†Îêú ÏπòÏàòÏÑ† Ìï®Ïàò ---
    function createModernDimensions(w, d, h) {
        const dimColor = 0x2563eb; // ÏßÑÌïú ÌååÎûÄÏÉâ (Í∞ÄÏãúÏÑ± ÎÜíÏùå)
        const dimWidth = 4;        // ÏÑ† ÎëêÍªò (Ïã§Î¶∞Îçî Î∞òÏßÄÎ¶Ñ)
        const offset = 200;        // Í∞ÄÍµ¨ÏôÄÏùò Í±∞Î¶¨

        // 1. ÎëêÍ∫ºÏö¥ ÏÑ† Í∑∏Î¶¨Í∏∞ (Ïã§Î¶∞Îçî ÌôúÏö©)
        const drawThickLine = (p1, p2) => {
            const vec = new THREE.Vector3().subVectors(p2, p1);
            const height = vec.length();
            const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            
            const geo = new THREE.CylinderGeometry(dimWidth, dimWidth, height, 8);
            const mat = new THREE.MeshBasicMaterial({ color: dimColor });
            const line = new THREE.Mesh(geo, mat);
            
            // Î∞©Ìñ• Ï†ïÎ†¨
            line.position.copy(mid);
            line.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), vec.clone().normalize());
            return line;
        };

        // 2. ÎÅùÏ†ê ÎßàÏª§ (ÏûëÏùÄ Íµ¨)
        const drawMarker = (pos) => {
            const geo = new THREE.SphereGeometry(dimWidth * 3, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: dimColor });
            const marker = new THREE.Mesh(geo, mat);
            marker.position.copy(pos);
            return marker;
        }

        // 3. Í≥†Ìï¥ÏÉÅÎèÑ ÎùºÎ≤® Ïä§ÌîÑÎùºÏù¥Ìä∏
        const createHighResLabel = (text) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            // Ìï¥ÏÉÅÎèÑ ÎÜíÏûÑ
            canvas.width = 512; 
            canvas.height = 256;
            
            // Î∞∞Í≤Ω Î∞ïÏä§ (Îë•Í∑º ÏÇ¨Í∞ÅÌòï + ÌÖåÎëêÎ¶¨)
            ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
            ctx.strokeStyle = "#2563eb";
            ctx.lineWidth = 10;
            roundRect(ctx, 20, 50, 472, 156, 40, true, true);

            // ÌÖçÏä§Ìä∏
            ctx.font = "bold 100px 'Noto Sans KR', sans-serif";
            ctx.fillStyle = "#1e3a8a"; // ÏïÑÏ£º ÏßÑÌïú ÌååÎûë
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 256, 128);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
            sprite.scale.set(400, 200, 1); // Ïä§ÏºÄÏùº ÌÇ§ÏõÄ
            return sprite;
        };

        // ÏπòÏàòÏÑ† ÏÑ∏Ìä∏ ÏÉùÏÑ± ÎèÑÏö∞ÎØ∏
        const buildDimSet = (start, end, labelText, labelOffsetVec) => {
            const group = new THREE.Group();
            group.add(drawThickLine(start, end));
            group.add(drawMarker(start));
            group.add(drawMarker(end));
            
            const label = createHighResLabel(labelText);
            const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            label.position.copy(mid).add(labelOffsetVec);
            group.add(label);
            return group;
        }

        // Í∞ÄÎ°ú (Width)
        dimGroup.add(buildDimSet(
            new THREE.Vector3(-w/2, 0, d/2 + offset),
            new THREE.Vector3(w/2, 0, d/2 + offset),
            `W: ${w}`,
            new THREE.Vector3(0, 0, 100)
        ));

        // ÎÜíÏù¥ (Height)
        dimGroup.add(buildDimSet(
            new THREE.Vector3(-w/2 - offset, 0, d/2),
            new THREE.Vector3(-w/2 - offset, h, d/2),
            `H: ${h}`,
            new THREE.Vector3(-150, 0, 0)
        ));

        // ÍπäÏù¥ (Depth)
        dimGroup.add(buildDimSet(
            new THREE.Vector3(w/2 + offset, 0, -d/2),
            new THREE.Vector3(w/2 + offset, 0, d/2),
            `D: ${d}`,
            new THREE.Vector3(150, 0, 0)
        ));
    }

    // Ï∫îÎ≤ÑÏä§ Îë•Í∑º ÏÇ¨Í∞ÅÌòï Í∑∏Î¶¨Í∏∞ ÎèÑÏö∞ÎØ∏
    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
    }

    function cleanupGroup(group) {
        scene.remove(group);
        group.traverse((child) => {
            if (child.isMesh || child.isSprite || child.isLine) {
                if(child.material.map) child.material.map.dispose();
                child.geometry.dispose();
                child.material.dispose();
            }
        });
    }

    function calculateCost(w, d, h, s) {
        const angleMeter = (h*4 + w*2*s + d*2*s) / 1000;
        const boardArea = (w * d * s) / 1000000;
        const price = (angleMeter * 3500) + (boardArea * 30000) + (s * 2500);
        const finalPrice = Math.floor(price / 100) * 100;
        document.getElementById('price-value').innerText = finalPrice.toLocaleString();
    }

    function downloadImage() {
        renderer.render(scene, camera);
        const link = document.createElement('a');
        link.download = 'angle_simulation.png';
        link.href = renderer.domElement.toDataURL("image/png");
        link.click();
    }

    function onWindowResize() {
        const container = document.getElementById('canvas-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    init();

</script>
</body>
</html>
