<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë§ì¶¤ ì•µê¸€ ì œì‘ ì‹œë®¬ë ˆì´í„°</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-body: #f3f4f6;
            --bg-panel: #ffffff;
            --text-main: #111827;
            --text-sub: #6b7280;
            --border: #e5e7eb;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: var(--bg-body);
            color: var(--text-main);
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        /* ì‚¬ì´ë“œë°” ìŠ¤íƒ€ì¼ (ëª¨ë°”ì¼ ëŒ€ì‘ ê°•í™”) */
        .sidebar {
            width: 220px; 
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        .header {
            padding: 15px;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-main);
        }

        .controls {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* ì•„ì´íŒ¨ë“œ ìŠ¤í¬ë¡¤ ë¶€ë“œëŸ½ê²Œ */
        }

        .input-group { margin-bottom: 15px; }
        
        .input-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-sub);
            margin-bottom: 5px;
        }

        .input-row {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        input[type="number"] {
            width: 100%;
            padding: 10px; /* í„°ì¹˜ ì˜ì—­ í™•ëŒ€ */
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 16px; /* iOS ìë™ ì¤Œ ë°©ì§€ìš© 16px */
            text-align: right;
            outline: none;
            transition: 0.2s;
            font-weight: 500;
            -moz-appearance: textfield; /* íŒŒì´ì–´í­ìŠ¤ í™”ì‚´í‘œ ì œê±° */
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        input[type="number"]:focus { 
            border-color: var(--primary); 
            background: #eff6ff;
        }
        .unit { font-size: 12px; color: var(--text-sub); width: 25px;}

        #btn-run {
            width: 100%;
            padding: 14px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 10px;
            margin-bottom: 20px; /* í•˜ë‹¨ ì—¬ë°± ì¶”ê°€ */
        }

        .footer-actions {
            padding: 15px;
            background: #f8fafc;
            border-top: 1px solid var(--border);
        }

        .btn-download {
            width:100%; 
            padding: 12px; 
            border:1px solid #d1d5db; 
            background:white; 
            border-radius:6px; 
            cursor:pointer;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-sub);
        }
        .btn-download:hover { background: #f3f4f6; color: var(--text-main); }

        .viewer {
            flex: 1;
            position: relative;
            background: #eef2f6;
        }

        #canvas-container { width: 100%; height: 100%; }

        .guide-text {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            color: #555;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>

    <div class="sidebar">
        <div class="header">
            <h1>ì•µê¸€ ì‹œë®¬ë ˆì´í„°</h1>
        </div>

        <div class="controls">
            <div class="input-group">
                <label>ê°€ë¡œ (Width)</label>
                <div class="input-row">
                    <input type="number" id="input-w" value="1200" step="100" min="300">
                    <span class="unit">mm</span>
                </div>
            </div>

            <div class="input-group">
                <label>ê¹Šì´ (Depth)</label>
                <div class="input-row">
                    <input type="number" id="input-d" value="600" step="100" min="300">
                    <span class="unit">mm</span>
                </div>
            </div>

            <div class="input-group">
                <label>ë†’ì´ (Height)</label>
                <div class="input-row">
                    <input type="number" id="input-h" value="1800" step="100" min="600">
                    <span class="unit">mm</span>
                </div>
            </div>

            <div class="input-group">
                <label>ì„ ë°˜ ë‹¨ìˆ˜</label>
                <div class="input-row">
                    <input type="number" id="input-s" value="5" step="1" min="2" max="10">
                    <span class="unit">ë‹¨</span>
                </div>
            </div>

            <button id="btn-run" onclick="updateFurniture()">ì‹¤í–‰í•˜ê¸°</button>
        </div>

        <div class="footer-actions">
            <button class="btn-download" onclick="saveImage()">ğŸ“· ì´ë¯¸ì§€ ì €ì¥</button>
            <div style="text-align:center; font-size:10px; color:#999; margin-top:5px;">
                ì•„ì´íŒ¨ë“œëŠ” ì´ë¯¸ì§€ë¥¼ ê¸¸ê²Œ ëˆŒëŸ¬ ì €ì¥í•˜ì„¸ìš”
            </div>
        </div>
    </div>

    <div class="viewer">
        <div id="canvas-container"></div>
        <div class="guide-text">
            íšŒì „: ë“œë˜ê·¸ | ì´ë™: ë‘ì†ê°€ë½ | ì¤Œ: í•€ì¹˜
        </div>
    </div>

<script>
    let scene, camera, renderer, controls;
    let furnitureGroup;
    let dimGroup;

    // ì…ë ¥ í•„ë“œ UX ê°œì„  (í´ë¦­ ì‹œ ì „ì²´ì„ íƒ/ì§€ì›€)
    document.addEventListener("DOMContentLoaded", () => {
        const inputs = document.querySelectorAll('input[type="number"]');
        inputs.forEach(input => {
            input.addEventListener('focus', function() {
                this.dataset.prevValue = this.value;
                this.value = '';
            });
            input.addEventListener('blur', function() {
                if(this.value === '') {
                    this.value = this.dataset.prevValue || 0;
                }
            });
            input.addEventListener('keydown', function(e) {
                if(e.key === 'Enter') {
                    this.blur(); // í‚¤ë³´ë“œ ë‚´ë¦¼
                    updateFurniture();
                }
            });
        });
        
        init();
    });

    function init() {
        const container = document.getElementById('canvas-container');

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeef2f6);

        // ì´ˆê¸° ì¹´ë©”ë¼ ìœ„ì¹˜ (ë‚˜ì¤‘ì— ìë™ì¡°ì •ë¨)
        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 10, 100000);
        camera.position.set(3000, 2500, 3000);

        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 100;
        controls.maxDistance = 10000;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // ë°”ë‹¥ ì•„ë˜ë¡œ í†µê³¼ ë°©ì§€

        // ì¡°ëª…
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(2000, 3000, 2000);
        dirLight.castShadow = true;
        // ê·¸ë¦¼ì ë²”ìœ„ ë„‰ë„‰í•˜ê²Œ
        dirLight.shadow.mapSize.set(2048, 2048);
        const d = 4000;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // ë°”ë‹¥
        const grid = new THREE.GridHelper(8000, 40, 0xcbd5e1, 0xe2e8f0);
        grid.material.opacity = 0.5;
        grid.material.transparent = true;
        scene.add(grid);

        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(10000, 10000),
            new THREE.MeshStandardMaterial({ color: 0xf8fafc, roughness: 0.8, metalness: 0.1 })
        );
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -2;
        plane.receiveShadow = true;
        scene.add(plane);

        window.addEventListener('resize', onWindowResize);

        updateFurniture();
        animate();
    }

    function updateFurniture() {
        if (furnitureGroup) cleanupGroup(furnitureGroup);
        if (dimGroup) cleanupGroup(dimGroup);

        const width = Number(document.getElementById('input-w').value) || 1200;
        const depth = Number(document.getElementById('input-d').value) || 600;
        const height = Number(document.getElementById('input-h').value) || 1800;
        const shelves = Number(document.getElementById('input-s').value) || 5;

        furnitureGroup = new THREE.Group();
        dimGroup = new THREE.Group();

        // === ê°€êµ¬ ìƒì„± ===
        const angleSize = 40;
        const angleThick = 3;
        
        const matSteel = new THREE.MeshStandardMaterial({ color: 0x334155, roughness: 0.5, metalness: 0.7 });
        const matWood = new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.9, metalness: 0.1, side: THREE.DoubleSide });

        // ê¸°ë‘¥ ìƒì„± í•¨ìˆ˜
        const createPost = (x, z, rotY) => {
            const post = new THREE.Group();
            const mesh1 = new THREE.Mesh(new THREE.BoxGeometry(angleSize, height, angleThick), matSteel);
            mesh1.position.set(0, height/2, -angleSize/2 + angleThick/2);
            mesh1.castShadow = true;
            const mesh2 = new THREE.Mesh(new THREE.BoxGeometry(angleThick, height, angleSize), matSteel);
            mesh2.position.set(-angleSize/2 + angleThick/2, height/2, 0);
            mesh2.castShadow = true;
            post.add(mesh1, mesh2);
            post.position.set(x, 0, z);
            post.rotation.y = rotY;
            return post;
        };

        const halfW = width / 2;
        const halfD = depth / 2;
        const offset = angleSize / 2;

        furnitureGroup.add(createPost(-halfW + offset, -halfD + offset, 0));
        furnitureGroup.add(createPost(halfW - offset, -halfD + offset, -Math.PI/2));
        furnitureGroup.add(createPost(-halfW + offset, halfD - offset, Math.PI/2));
        furnitureGroup.add(createPost(halfW - offset, halfD - offset, Math.PI));

        // ì„ ë°˜ ìƒì„±
        const shelfSpacing = (height - 100) / (shelves - 1);
        const frameGeoW = new THREE.BoxGeometry(width, angleSize, angleThick);
        const frameGeoD = new THREE.BoxGeometry(angleThick, angleSize, depth);
        const boardGeo = new THREE.BoxGeometry(width - 5, 12, depth - 5);

        for (let i = 0; i < shelves; i++) {
            const y = 50 + (i * shelfSpacing);
            const board = new THREE.Mesh(boardGeo, matWood);
            board.position.set(0, y + 6, 0);
            board.castShadow = true;
            board.receiveShadow = true;
            furnitureGroup.add(board);

            const fw1 = new THREE.Mesh(frameGeoW, matSteel); fw1.position.set(0, y, halfD - angleThick/2);
            const fw2 = new THREE.Mesh(frameGeoW, matSteel); fw2.position.set(0, y, -halfD + angleThick/2);
            const fd1 = new THREE.Mesh(frameGeoD, matSteel); fd1.position.set(halfW - angleThick/2, y, 0);
            const fd2 = new THREE.Mesh(frameGeoD, matSteel); fd2.position.set(-halfW + angleThick/2, y, 0);
            furnitureGroup.add(fw1, fw2, fd1, fd2);
        }

        // ì¹˜ìˆ˜ì„  ìƒì„±
        createModernDimensions(width, depth, height);

        scene.add(furnitureGroup);
        scene.add(dimGroup);

        // [ì¤‘ìš”] ì¹´ë©”ë¼ë¥¼ ê°€êµ¬ ì‚¬ì´ì¦ˆì— ë§ì¶° ìë™ ì¡°ì •
        fitCameraToSelection(camera, controls, [furnitureGroup, dimGroup], 1.5);
    }

    // ì¹´ë©”ë¼ ìë™ ì¤Œì¸/ì¤Œì•„ì›ƒ í•¨ìˆ˜
    function fitCameraToSelection(camera, controls, selection, fitOffset = 1.2) {
        const box = new THREE.Box3();
        
        selection.forEach(object => {
            box.expandByObject(object);
        });
        
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        
        const maxSize = Math.max(size.x, size.y, size.z);
        const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
        const fitWidthDistance = fitHeightDistance / camera.aspect;
        const distance = fitOffset * Math.max(fitHeightDistance, fitWidthDistance);
        
        const direction = controls.target.clone().sub(camera.position).normalize().multiplyScalar(distance);

        controls.maxDistance = distance * 10;
        controls.target.copy(center); // ì‹œì ì„ ê°€êµ¬ ì¤‘ì‹¬ìœ¼ë¡œ ë³€ê²½
        
        // ë¶€ë“œëŸ¬ìš´ ì´ë™ ëŒ€ì‹  ì¦‰ì‹œ ì´ë™ (ì´ˆê¸°í™” ëŠë‚Œ)
        camera.near = distance / 100;
        camera.far = distance * 100;
        camera.updateProjectionMatrix();

        camera.position.copy(controls.target).sub(direction);
        controls.update();
    }

    function createModernDimensions(w, d, h) {
        const dimColor = 0x2563eb;
        const dimWidth = 4;
        const offset = 250; // ì¹˜ìˆ˜ì„  ê°„ê²©ì„ ë” ë„“í˜

        const drawThickLine = (p1, p2) => {
            const vec = new THREE.Vector3().subVectors(p2, p1);
            const height = vec.length();
            const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            const geo = new THREE.CylinderGeometry(dimWidth, dimWidth, height, 8);
            const mat = new THREE.MeshBasicMaterial({ color: dimColor, depthTest: false }); // depthTest falseë¡œ ë°”ë‹¥ ìœ„ë¡œ ê°•ì œ ë Œë”ë§
            const line = new THREE.Mesh(geo, mat);
            line.position.copy(mid);
            line.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), vec.clone().normalize());
            line.renderOrder = 999;
            return line;
        };

        const drawMarker = (pos) => {
            const geo = new THREE.SphereGeometry(dimWidth * 4, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: dimColor, depthTest: false });
            const marker = new THREE.Mesh(geo, mat);
            marker.position.copy(pos);
            marker.renderOrder = 999;
            return marker;
        }

        const createHighResLabel = (text) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 256;
            
            ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
            ctx.strokeStyle = "#2563eb";
            ctx.lineWidth = 15;
            roundRect(ctx, 20, 50, 472, 156, 40, true, true);

            ctx.font = "bold 100px 'Noto Sans KR', sans-serif";
            ctx.fillStyle = "#1e3a8a";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 256, 128);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false }));
            sprite.scale.set(500, 250, 1);
            sprite.renderOrder = 1000;
            return sprite;
        };

        const buildDimSet = (start, end, labelText, labelOffsetVec) => {
            const group = new THREE.Group();
            group.add(drawThickLine(start, end));
            group.add(drawMarker(start));
            group.add(drawMarker(end));
            
            const label = createHighResLabel(labelText);
            const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            label.position.copy(mid).add(labelOffsetVec);
            group.add(label);
            return group;
        }

        // ê°€ë¡œ (W)
        dimGroup.add(buildDimSet(
            new THREE.Vector3(-w/2, 0, d/2 + offset),
            new THREE.Vector3(w/2, 0, d/2 + offset),
            `W: ${w}`,
            new THREE.Vector3(0, 50, 100) // Yì¶•ìœ¼ë¡œ ì‚´ì§ ë„ì›€
        ));

        // ë†’ì´ (H)
        dimGroup.add(buildDimSet(
            new THREE.Vector3(-w/2 - offset, 0, d/2),
            new THREE.Vector3(-w/2 - offset, h, d/2),
            `H: ${h}`,
            new THREE.Vector3(-180, 0, 0)
        ));

        // ê¹Šì´ (D)
        dimGroup.add(buildDimSet(
            new THREE.Vector3(w/2 + offset, 0, -d/2),
            new THREE.Vector3(w/2 + offset, 0, d/2),
            `D: ${d}`,
            new THREE.Vector3(180, 50, 0) // Yì¶•ìœ¼ë¡œ ì‚´ì§ ë„ì›€
        ));
    }

    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
    }

    function cleanupGroup(group) {
        scene.remove(group);
        group.traverse((child) => {
            if (child.isMesh || child.isSprite || child.isLine) {
                if(child.material.map) child.material.map.dispose();
                child.geometry.dispose();
                child.material.dispose();
            }
        });
    }

    // ì•„ì´íŒ¨ë“œ/PC í†µí•© ì €ì¥ í•¨ìˆ˜
    function saveImage() {
        renderer.render(scene, camera);
        const dataURL = renderer.domElement.toDataURL("image/png");

        // ëª¨ë°”ì¼(iOS ë“±) ì²´í¬
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

        if (isMobile) {
            // ëª¨ë°”ì¼ì—ì„œëŠ” ìƒˆ íƒ­ìœ¼ë¡œ ì´ë¯¸ì§€ ì—´ê¸° (ê¸¸ê²Œ ëˆŒëŸ¬ ì €ì¥ ìœ ë„)
            const win = window.open();
            if (win) {
                win.document.write(`<img src="${dataURL}" style="width:100%; height:auto;" />`);
                win.document.title = "ì´ë¯¸ì§€ ê¸¸ê²Œ ëˆŒëŸ¬ ì €ì¥";
            } else {
                alert('íŒì—… ì°¨ë‹¨ì„ í•´ì œí•´ì£¼ì„¸ìš”.');
            }
        } else {
            // PCì—ì„œëŠ” ë°”ë¡œ ë‹¤ìš´ë¡œë“œ
            const link = document.createElement('a');
            link.download = `ì•µê¸€ê²¬ì _${new Date().getTime()}.png`;
            link.href = dataURL;
            link.click();
        }
    }

    function onWindowResize() {
        const container = document.getElementById('canvas-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
